# 해답

**A1.** `인덱스 / 빠르 / 복잡 / 비효율적 / 포인터 / 느리 / 쉽다`

> 배열은 (인덱스)를 이용해 접근이 (빠르)지만 데이터의 삽입과 삭제 과정이 (복잡)하여 (비효율적)이다.
> 
> 연결리스트는 (포인터)로 데이터에 접근하므로 접근 속도가 (느리)지만, 노드의 삽입과 삭제가 (쉽다).

**A2.** `사용하는 이유 : 단순 배열로 구현된 큐의 한계를 해결하기 위해`
 `원형 큐의 한계 : 가득찼을 때 더이상 삽입이 불가능`

> 단순 배열로 구현된 큐는 비어있어도 사용할 수 없는 공간이 생긴다는 한계가 있다. 이를 해결하기 위한 방법 중 하나가 원형 큐의 사용이다.
>
> 원형 큐에서는 pop과 push가 반복적으로 일어날 때 비어있어도 사용할 수 없는 공간이 생긴다는 문제점은 해결하지만, 원형 큐가 가득 찼을 때 더 이상 삽입이 불가능하다는 문제가 발생한다.

**A3.** `탐색의 정확성을 높이기 위해 사용`

> 컴퓨터가 2진법을 사용하는 이유와 비슷함.
> 
> 표현이나 데이터의 표현이나 연산이나 특히 이 트리에서는 탐색을 단순화하기 위해 사용한다.
> 
> 여기서 단순화한다는 것은 곧 정확성을 높인다는 것이다.

**A4.** `3번`

> 버블정렬은 서로 이웃한 데이터들을 비교하여 큰 데이터를 뒤로 보내는 과정을 반복하여 정렬하는 방식이다
>
> 버블정렬을 통해 2413을 정렬하는 과정은 아래와 같다.
> 
> 2413 -> 2,4비교 -> 2413 -> 4,1비교(1) -> 2143 -> 4,3비교(2) -> 2134 -> 3,4자리 찾음 -> 2,1비교(3) -> 1234 -> 1,2자리 찾음
>
> 위 과정에서 숫자교환은 총 3번 일어났다.

**A5.** `5번, 2번`

> **1. 선형탐색** : 하나씩 숫자를 비교하며 탐색하는 방법이다.
> 
> 처음부터 순서대로 1과15, 3과15, 8과15, 11과15, 15와15를 비교하여 같은 숫자를 찾았으니 비교횟수는 5번이다.
>    
> **2. 이진탐색** : 데이터를 반으로 쪼개면서 탐색하는 방법이다.
>  
> (low인덱스와 high인덱스보다 작은 동안 mid인덱스의 값이 key와 같을 때까지 반복하면서 탐색)
>
> 먼저, low=0, high=6, mid1=3에서 인덱스가 mid1일 때 값이 11인데,
> key값인 15보다 작으므로 mid1 오른쪽의 데이터를 사용한다. --> 비교1번
> 
> 쪼개진 데이터 `15,17,20`에서도 반복한다.
>
> low=4, high=6, mid2=5에서 인덱스가 mid2일 때 값이 17인데,
> 15보다 크므로 mid2 왼쪽의 데이터를 사용한다. --> 비교2번
>
> 쪼개진 데이터 `15`에서 low=4,high=4 : low가 high보다 작지 않으므로 탐색 끝
