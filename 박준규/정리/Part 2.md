# Part 2 - 데이터 표현과 디지털 논리

<details>
<summary>진법</summary>


### 진법

- 수를 표현하는 숫자 개수와 수를 구성하는 숫자의 값을 정의한 수 체계
- 10진법, 2진법, 8진법, 16진법, …
- 진수는 해당 진법으로 나타낸 수

### 10진법

- 0에서 9까지 10개 숫자를 사용해 수를 표현하는 방법
- 주로 사람이 사용
- 432(10)
    - 10 : 기수 - 10진법라는 수를 알림

### 2진법

- 0과 1, 단 2개의 숫자만 사용해 수를 표현하는 방법
- 주로 컴퓨터가 사용

### 8진법

- 0에서 7까지의 8개의 숫자들을 사용해 수를 표현하는 방법

### 16진법

- 0에서 15까지의 16개의 숫자들을 사용해 수를 표현하는 방법
- 10부터 15까지의 수는 A ~ F의 영문자로 표기
    - 10 : A
    - 11 : B
    - 12 : C
    - 13 : D
    - 14 : E
    - 15 : F

### 진법 변환

- **정수부와 소수부의 변환 과정이 다름**
- **10진수 → 2진수**
    - 정수부
        - 정수를 2로 **나누면서** 몫, 나머지 구함
        - 더 이상 나누어지지 않을 때까지 반복
        - 나머지를 거꾸로 나열
    - 소수부
        - 소수를 2로 **곱하면서**
        - 소수부분이 0이 될 때까지 반복
        - 정수 부분을 순서대로 나열
- **10진수 → 8진수 or 16진수**
    - 10진수 → 2진수 진법 변환과 동일(대신, 8 또는 16으로 나눔)
- **2진수 → 10진수**
    - 정수부
        - 2진수의 각 자릿수를 지수 승에 맞게 곱한 후 모두 더함
    - 소수부
        - 정수의 경우와 변환 방식 동일
        - 소수점 아래 숫자들은 자리번호가 음수(지수 부분이 음수가 됨)
- **8 / 16진수 → 10진수**
    - 2진수 → 10진수 진법 변환과 동일(대신, 8 또는 16으로 곱함)
- **2진수 → 8 / 16진수**
    3비트씩 분할(2진수 → 8진수)
    4비트씩 분할(2진수 → 16진수)
    
    - 소수점을 기준으로 3 / 4 비트씩 분할
    - 분할된 묶음을 10진수로 변환
- 8 / 16진수 → 2진수
    3비트씩 분할(8진수 → 2진수)
    4비트씩 분할(16진수 → 2진수)
    - 수를 구성하는 숫자를 각각 3 / 4 비트씩 분할

</details>

<details>
<summary>데이터</summary>


### 비트

- 컴퓨터의 가장 작은 정보 단위
- 2진수 0, 1 중 하나만 표현할 수 있는 크기

### 바이트

- 컴퓨터 정보 처리의 기본 단위
- 1bit 8개로 구성
    - 총 256개의 데이터 표현 가능

### 워드

- 컴퓨터가 한 번에 처리할 수 있는 데이터 크기
- 컴퓨터에 따라 1워드의 크기가 다르다
    - 8, 16, 32, 64비트

### 정수

- 양의 정수
- 0
- 음의 정수

### 컴퓨터에서의 정수 표현

- 부호 없는 정수(unsigned integer)
    - 0보다 크거나 같은 정수
- 부호 있는 정수(signed integer)
    - 음수, 0, 정수

### 부호 없는 정수의 덧셈 : 1워드 = 8비트

- 8비트가 넘을 경우(오버 플로우 발생) - 값의 표현 범위 벗어나는 상태

### 부호 있는 정수 표현
- 부호화 절댓값
- 부호화 보수
    - 부호화 1의 보수
    - 부호화 2의 보수

### 부호화 절댓값 표현

- 오버플로우에 의한 계산 오류
- 0에 대한 표현이 두 가지
    - 0은 양수도, 음수도 아닌 수

### 보수

- 보충해 주는 수
- n의 보수
    - 어떤 수가 n이 되기 위해 더해야 하는 수
- 1의 보수는 0 → 1, 1 → 0으로 바꾸기
- 2의 보수는 1의 보수에서 1만 더하기
- 컴퓨터는 2의 보수로 연산

### 2의 보수
- 컴퓨터에서 사용하는 부호화 2의 보수
    - 양수 : 부호화 절댓값 = 부호화 1의 보수 = 부호화 2의 보수
    - 음수 : 부호화 2의 보수
        - **부호 비트는 절대로 바뀌지 않는다!!**

### 컴퓨터에서 부호화 2의 보수를 사용하는 이유

- 오버 플로우에 대한 계산 오류 해결
- 0에 대한 표현이 한 가지로 통일

</details>

<details>
<summary>정보 표현</summary>


### 실수의 표현

- 고정 소수점 표현
- 부동 소수점 표현
    - 컴퓨터는 실수를 부동 소수점으로 표현
    - 정규화
        - 부동 소수점 표현을 위한 형식

### 문자의 표현

- 아스키 코드
    - 미국
    - ASCII
    - 하나의 문자를 7비트로 표현
        - 실제로는 패리티 비트 1비트 포함하여 8비트를 사용
    - 128개의 문자 표현
- 유니코드
    - 전 세계의 모든 문자를 표현하기 위해 설계
    - 하나의 문자를 16비트(2바이트)로 표현
    - 65,536 개의 문자 표현 가능

</details>

<details>
<summary>논리 연산</summary>


### 불 값

- 참
    - True
    - 1
- 거짓
    - False
    - 0

### 불 연산자

- AND
- OR
- NOT

### 불 대수

- 교환 법칙
- 결합 법칙
- 분배 법칙
- 항등 법칙
    - 0과 or은 항상 자기 자신
    - 1과 and는 항상 자기 자신
- 보수 법칙
    - A or not A = 1
    - A and not A = 0
- 멱등 법칙
    - A or A = A
    - A and A = A
- 드모르간 법칙

</details>
