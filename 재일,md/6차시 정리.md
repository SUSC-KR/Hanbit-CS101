# 정보의 표현: 부호 있는 정수

### 부호 있는 정수 표현의 구조
                  데이터비트 정수의 절대값 / 1의 보수, 2의 보수  
         □   /    □□□□□□□
    부호비트 양수: 0 , 음수: 1

### 부호 있는 정수
  - 부호화 절댓값
  - 부호화 보수
    - 부호화 1의 보수
    - 부호화 2의 보수

### 부호화 절댓값 표현

    +7을 나타내면 _0_ 0000111
    -7을 나타내면 _1_ 0000111

  - 8비트로 표현 가능한 범위
    - -127 ~ +127
    - -(2^n-1 - 1) ~ + (2^n-1 - 1) / 부호화 절대값 표현에는 한계가 있다.

  1. 오버플로우에 의한 계산 오류
      - ex) 01101010₂ (106) + 10110011₂ (-51) = _1_ 00011101₂ => 29(X)
 
  3. 0에 대한 표현이 두 가지
     - 0은 양수도, 음수도 아닌 수
     - _0_ 0000000₂ = +0
     - _1_ 0000000₂ = -0

## 보수
  - 보충해 주는 수
  - n의 보수
    - 어떤 수가 n이 되기 위해 더 해야 하는 수      /   ex) 1에 대한 10의 보수: 9 , 5에 대한 9의 보수: 4
    - n진수에 대해, n의 보스, n-1 의 보수 존재
   
### 2진수의 보수
  - 2의 보수 = 1의 보수 +1
  - 1의 보수 = 0 -> 1, 1 -> 0
  - 컴퓨터에서는 부호화 2의 보수를 사용한다.

### 컴퓨터에서 사용하는 부호화 2의 보수
  - 양수: 부호화 절댓값 = 부호화 1의 보수 = 부호화 2의 보수
    - ex) 73 = 01001001₂
  - 음수: 부호화 2의 보수
    - ex) -73 = 11001001₂ (부호화 절댓값) = 10110110₂ (부호화 1의 보수) = 10110111₂ (부호환 2의 보수)  => 컴퓨터에서 사용하는 음수 표현이다.

### 부호화 2의 보수를 사용하는 이유?
  1. 오버프로우에 대한 계산 오류 해결
  2. 0에 대한 표현이 한가지로 통일

### 요약하자면...
  - 1의 보수는 0 -> 1, 1 -> 0으로 바꾸기만 하면 된다.
  - 2의 보수는 1의 보수에서 1만 더 하면 된다.
  - 컴퓨터에서는 2의 보수로 연산한다.

### 예제문제
  1. 부호화 2의 보수를 사용하는 이유를 설명하시오.





