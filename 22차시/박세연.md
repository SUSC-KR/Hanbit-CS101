<!-- @format -->

# **22차시\_데이터의 대기 공간: 큐**

### 큐 (queue)

- 데이터의 삽입과 삭제가 서로 반대쪽 끝에서 일어나는 구조
- 선입선출 FIFO (First In First Out)

</br>

### 배열로 구현한 큐

- 현재 큐의 상태?
  - rear == (큐 크기 -1)?
    - 아니면 삽입 가능
    - 같으면 삽입 불가 (큐가 가득 찼기 때문)
  - front == rear?
    - 같으면 삭제/삽입 모두 불가
      - 단순 배열로 구현된 큐의 한계가 큼
    - 해결방법
      - front와 rear가 모두 가장 끝까지 이동 했을 때, front 와 rear 초기화
      - 원형 큐

### 원형큐 (circular queue)

- 논리적으로 큐의 처음과 끝이 연결된 구조

</br>

### 연결리스트로 구현한 큐

- head pointer를 front 노드로 사용하지 않음!!
  - front 노드는 계속 바뀌기 때문에

</br>

---

## 예제 문항

1. 큐는 (FIFO / LIFO) 이다.
2. 배열로 구현한 큐의 한계는 무엇인가요?

---

답) 1. FIFO &nbsp;&nbsp; 2. POP 연산을 수행할 때마다 배열에서 사용할 수 있는 공간이 줄어든다.
