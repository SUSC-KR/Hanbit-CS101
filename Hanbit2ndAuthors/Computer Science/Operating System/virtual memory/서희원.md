# 가상 메모리

## 연속 메모리 할당

프로세스에 연속적인 메모리 공간 할당 방식

### 스와핑

메모리 안에 현재 실행하지 않는 프로세스를 잠깐 다른 곳으로 쫓아내고,

그 빈 공간에
또 다른 프로세스를 적재하여 실행하는 방식이다.

- 스왑 영역
  프로세스들이 쫓겨나는 보조기억장치의 일부영역
- 스왑 아웃
  현재 실행되지 않는 프로세스들이 메모리에서 스왑 영역으로 옯겨지는 것
- 스왑인
  스왑 아웃의 반대 버전

스와핑을 통해 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우 **프로세스들을 동시 실행할 수 있다**.

동시에 실행가능한 이유는 메모리 내에 프로세스들을 계속 스와핑하기 때문이다.

### 메모리 할당

비어있는 메모리 공간에 프로세스를 연속적으로 할당하는 방식은 어떻게 될까?

1. 최초 적합

   메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식

   검색을 최소화 할 수 있고, 결과적으로 빠른 할당이 가능하다.

2. 최적 적합

   메모리의 빈 공간을 모두 검색한 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식

3. 최악 적합

   메모리의 빈 공간을 모두 검색한 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식

### 외부 단편화

연속 메모리 할당은 메모리를 효율적으로 사용하는 방법이 아니다.

외부 단편화라는 문제 때문이다.

만약 순서대로 메모리에 프로세스들을 할당하며 중간에 작은 크기의 용량을 가진 프로세스가 끝난다고 가정하자.

그렇다면 중간에 작은 메모리 공간들이 남게 되는데, 이는 결국 그 공간 보다 큰 프로세스를 적재하기 어려워 메모리 낭비가 된다.

이 현상을 **외부 단편화**라 한다.

이 문제를 해결하기 위해 대표적인 방법으로 메모리를 **압축**하는 방법이 있다.

말 그대로 메모리의 흩어진 프로세스들을 하나로 모으는 방법이다.

다만 이 방법을 사용하면 중간에 진행 중인 프로세스는 중지해야 하고, 메모리에 있는 내용을 옮기는 데 많은 오버헤드를 야기하며, 어떤 프로세스를 어떻게 움직여야 하는지 명확한 방법이 없다.

그래서 압축의 개선방안으로 가상 메모리 기법, 그 중에도 **페이징 기법**을 사용한다.

## 페이징을 통한 가상 메모리 관리

**가상 메모리**는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다.

### 페이징이란

만약 메모리와 프로세스를 일정 단위로 자르고, 이를 메모리에 불연속적으로 할당할 수 있다면, 외부 단편화는 발생하지 않는다.

이것이 **페이징**이다.

**페이징**은 프로세스의 논리 주소 공간을 **페이지**라는 일정한 단위로 자르고,

메모리 물리 주소 공간을 **프레임**이라는 **페이지**와 동일한 크기의 일정한 단위로 자른 뒤

페이지를 **프레임**에 할당하는 가상 메모리 관리 기법이다.

페이지 시스템에서 스왑 아웃은 **페이지 아웃**

스왑 인은 **페이지 인**이라 부르기도 한다.

그래서 일부 프로세스를 스왑하며 처리한다.

### 페이지 테이블

그러나 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU입장에서 이를 순차적으로 실행할 수 없다.

그래서 페이징 시스템은 프로세스가 물리 주소의 불연속적으로 배치되더라도 논리 주소에는 연속적으로 배치되도록 **페이지 테이블**을 이용한다.

그래서 CPU가 페이지 번호만 보고 현재 어떤 페이지가 어떤 프레임에 할당되었는지 알려준다.

하지만 페이징은 내부 단편화라는 문제를 야기할 수 있다.

모든 프로세스가 페이지와 딱 떨어지지는 않기 때문에 남는 공간을 의미한다.

페이지의 크기가 너무 작다면 페이지 테이블의 크기가 낭비되고, 페이지의 크기가 너무 크다면 내부 단편화가 커지기 때문에 적당히 크기를 조정하는 것이 중요하다.

### PTRB

프로세스마다 프로세스 테이블을 가지고 있고, 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있다.

그리고 CPU 내의 **페이지 테이블 베이스 레지스터(Page Table Base Register, PTBR)**는 각 프로세스의 페이지 테이블이 적재된 주소를 가지키고 있다.

하지만 CPU는 페이지 테이블을 보기위해 한번, 페이지 테이블을 통해 알게 된 프레임에 접근하기 위해 한번 이렇게 두번의 메모리 접근이 필요하다.

그래서 소요 시간이 두배가 걸린다.

### TLB

이를 해결하기 위해 CPU 곁에 **TLB(Translation Lookaside Buffer)**라는 페이지 테이블에 캐시 메모리를 둔다.

TLB는 페이지 테이블의 캐시이기 때문에 페이지 테이블의 일부 내용을 저장한다.

참조 지역성에 근거해 주로 최근 사용된 페이지 위주로 가져와 저장한다.

CPU가 발생한 논리 주소에 페이지 번호가 TLB가 있을 경우 이를 **TLB 히트**라 한다.

이 경우 페이지에 적재된 프레임을 알기 위해 메모리에 접근할 필요가 없다.

그래서 메모리에 한번만 접근하면 된다.

하지만 페이지 번호가 TLB에 없다면 이를 **TLB 미스**라 한다.

### 페이징에서의 주소 변환

특정 주소에 접근하기 위해 두가지 정보가 필요하다.

1. 어떤 페이지 혹은 프레임에 접근하고 싶은지
2. 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지

그렇기에 페이징 시스템에는 모든 논리 주소가 기본적으로 **페이지 번호**와 **변위**로 이루어져 있다.

만약 CPU가 32비트 주소를 내보냈다면 이중 N비트는 페이지 번호, 32-N비트는 변위 이런 식으로 이루어져 있다.

### 페이지 테이블 엔트리

페이지 테이블의 각각의 행을 **페이지 테이블 엔트리**라 한다.

페이지 테이블에 페이지 번호와 프레임 번호만 있다고 생각하지만, 사실은 더 많은 정보들이 있다.

**유효 비트**

현재 해당 페이지에 접근 가능한지 여부를 알려준다.

만약 유효 비트의 값이 1이면 메모리에 적재되어 있다는 의미이고,

0이면 메모리에 적재되지 않았다는 의미이다.

만약 CPU가 유효 비트가 0인 메모리에 적재되어 있지 않은 페이지로 접근하려 하면 **페이지 폴트**라는 예외가 발생한다.

페이지 폴트가 발생한 경우 처리 과정은 다음과 같다.

1. CPU는 기존 작업을 백업한다.
2. 페이지 폴트 처리 루틴을 실행한다.
3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경해 준다.
4. 페이지 폴트 처리했다면 이제 CPU는 해당 페이지에 접근할 수 있다.

**보호 비트**

페이지 보호 기능을 위해 존재하는 비트

보호 비트의 값이 1이면 읽고 쓰기가 모두 가능하고

0이면 읽기만 가능하다.

만약 읽기 전용 페이지에 쓰기를 시도하면 운영체제에서 이를 막아준다.

더 구체적으로 구현하면 3개의 비트를 설정해서 읽기, 쓰기, 실행이 가능한지 표시한다.

**참조 비트**

CPU가 이 페이지에 접근한 적 있는지 여부를 나타낸다.

적재 이후 CPU가 읽거나 쓴 페이지는 참조 비트가 1로 세팅되어 있고

아니면 참조 비트가 0으로 유지 된다.

**수정 비트(더티 비트)**

해당 페이지에 데이터를 쓴 적 있는지 없는지 수정 여부를 알려준다.

1이면 변경된 적 있는 페이지

0이면 변경된 적 없는 페이지이다.

**그런데 수정 비트는 왜 필요할까?**

수정 비트는 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지를 판단하기 위해 존재한다.

만약 한번도 접근하지 않거나 읽기만 했다면 보조기억장치에 저장된 페이지의 내용과 메모리에 저장된 페이지 내용이 서로 같다.

그래서 한 번도 수정된 적 없는 페이지가 스왑 아웃될 경우 추가 작업 없이 새로 적재된 페이지에 덮어쓰기만 하면 된다.

하지만 쓰기 작업을 수행했다면 서로 다른 값을 가지고 있기 때문에 보조기억장치에 변경된 값을 기록하는 작업이 필요하다.

더 많은 정보는 github kangtegong self-learning-cs로..

### 페이징의 이점 - 쓰기 시 복사

페이징의 이점으로 대표적인 것은 프로세스 간에 페이지를 공유할 수 있다는 점이다.

그 예시로 쓰기 시 복사가 있다.

부모 프로세스와 동일한 자식 프로세스가 생성되면 자식 프로세스로 하여금 부모 프로세스와 동일한 프레임을 가리킨다.

이렇게 되면 굳이 부모 프로세스의 메모리의 공간을 복사하지 않고도 동일한 코드 및 데이터 영역을 가리킬 수 있다.

만약 읽기 작업만 한다면 이렇게 해도 되지만,

프로세스 간에는 자원을 공유하지 않기 때문에

쓰기 작업을 하면 그 순간 해당 페이지가 별도의 공간으로 복제된다.

이를 통해 프로세스 생성 시간을 줄이고 메모리 공간 절약도 가능하다.

### 계층적 페이징

모든 페이지 테이블을 항상 메모리에 유지하지 않는 방법

여러 단계의 페이지를 둔다는 점에서 **다단계 페이지 테이블**이라 부른다.

메모리에 필요한 테이블은 넣고 불필요하면 보조기억장치에 넣으면 그만이다.

그리고 CPU가 발생하는 논리 주소가 달라진다.

변위 | 페이지 번호 → 바깥 페이지 번호 | 안쪽 페이지 번호 | 변위

이 논리 주소를 토대로 다음과 같이 주소를 변환한다.

1. 바깥 페이지 번호를 통해 페이지 테이블의 페이지를 찾기
2. 페이지 테이블의 페이지를 통해 프레임 번호를 찾고 변위를 더함으로서 물리 주소 얻기

계층은 여러 계층으로 나뉘어 질 수 있으나,

그만큼 페이지 폴트가 발생할 경우 메모리 참조 횟수가 많아지므로 반드시 좋다고 볼 수 없다.

## 페이지 교체와 프레임 할당

### 요구 페이징

프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법

기본적인 양상은 다음과 같다.

1. CPU가 특정 페이지에 접근하는 명령어를 실행한다.
2. 해당 메모리에 있을 경우(유효 비트가 1일 경우) CPU는 적재된 프레임에 접근한다.
3. 유효 비트가 0일 경우 페이지 폴트가 발생한다.
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다.
5. 다시 1번을 처리한다.

**순수 요구 페이징 기법**: 아무 페이지도 메모리에 적재하지 않은 채 무작정 실행하여 페이지 폴트 발생 빈도를 떨어트리는 기법

요구 페이징 시스템을 안정적으로 작동시키기위해 필연적으로 두가지 해결해야한다.

- 페이지 교체
  페이지 폴트 처리 루틴을 계속 사용하다 보면 메모리가 가득 차버리는데, 이를 해결하기 위해 **페이지 교체 알고리즘**을 사용한다.
  ### 페이지 교체 알고리즘
  일반적으로 페이지 폴트를 가장 적게 일으키는 알고리즘을 좋은 알고리즘이라 한다.
  페이지 참조열을 통해 페이지 폴트 횟수를 알 수 있다.
  - **FIFO 페이지 교체 알고리즘**
    가장 먼저 올라온 페이지 부터 내쫓는 방식이다.
    그래서 큐처럼 작동하여 메모리에 페이지를 저장하고, 가장 오래된 페이지를 보조기억장치로 내보낸다.
    하지만 실행시간이 긴 페이지는 강제로 쫓아낼 수 없기 때문에 좋은 방식은 아니다.
    이 문제를 어느정도 개선한 **2차 기회 페이지 교체 알고리즘**이 있다.
    이 알고리즘은 참조 비트를 보고 만약 참조 비트가 1일 경우, 당장 내쫓지 않고 참조 비트를 0으로 만든 뒤 현재 시간을 적재 시간으로 설정한다.
  - **최적 페이지 교체 알고리즘**
    CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘이다.
    메모리 안에 있는 페이지 중 그나마 필요없는 페이지는 오랫동안 사용되지 않을 페이지이다.
    그래서 보조기억장치로 내보내야할 페이지는 사용 빈도가 가장 낮은 페이지이므로 이를 찾아 교체하는 알고리즘이다.
    실제로 다른 알고리즘보다 가장 적은 횟수로 페이지 폴트가 발생하는 알고리즘이다.
    하지만 구현하기가 어려워서 실제 운영체제에 사용하기 보다는 다른 페이지 교체 알고리즘의 이론 상 성능을 평가하기 위한 목적으로 사용된다.
  - **LRU 페이지 교체 알고리즘**
    가장 오랫동안 사용되지 않을 페이지를 교체하는 것이 아닌
    가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘이다.
    이 알고리즘은 페이지마다 마지막으로 사용한 시간을 토대로 최근에 가장 사용이 적었던 페이지를 교체한다.
- 스래싱과 프레임 할당
  메모리에서 프로세스가 사용 가능한 프레임수가 적어도 페이지 폴트는 자주 발생한다.
  그래서 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제를 **스래싱**이라 한다.
  운영체제는 이 스레싱 문제를 해결하기 위해 최소한의 프레임 수를 파악하고 프로세스들에 적절한 수 만큼 프레임을 할당해줘야 한다.
  프레임 할당 방식
  - 균등 할당: 모든 프로세스에 같은 수의 프레임을 할당한다.
  - 비례 할당: 모든 프로세스의 크기 만큼 비례해서 프레임을 할당한다.

하지만 이 방식은 프로세스의 크기와 필요한 프레임이 비례한 것은 아니기 때문에 프로세스를 실행하며 배분할 프레임을 정하는 방식으로 대체할 수 있다.

- **작업 집합 모델**
  프로세스가 일정 기간 동안 참조한 페이지 집합을 기억하여 빈번한 페이지 교체를 방지한다.
  CPU가 특정 시간 동안 주로 참조한 페이지 개수만큼만 프레임을 할당하면 페이지 교체는 빈번하게 발생하지 않는다.
  실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합을 **작업 집합**이라 한다.
  CPU가 과거 주로 참조한 페이지를 작업 집합에 포함한다면 운영체제는 작업 집합의 크기만큼 프레임을 할당해주면 된다.
- **페이지 폴트 빈도**
  페이지 폴트율과 할당된 프레임 수는 서로 반비례 관계를 가진다.
  그래서 페이지 폴트율을 기준으로 상한선, 하한선을 그어 이 범위 안에서만 프레임을 할당한다.
