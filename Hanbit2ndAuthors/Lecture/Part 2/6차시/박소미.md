# 6차시. 정보의 표현: 부호 있는 정수
학습일 : 2024-02-01(목)

</br></br>

## 부호의 표현
### 부호 있는 정수의 표현
- ***구조***

<img src ="https://github.com/fsm12/Hanbit-CS101/assets/74345771/5021c05f-6398-4258-9f1a-da024cc8776d">

</br></br>

- ***실제 표현***

&nbsp; &nbsp; 음수면 부호비트는 1, 양수이면 부호비트는 0으로 표시

<img src ="https://github.com/fsm12/Hanbit-CS101/assets/74345771/36003ee1-98a0-453b-98e3-0bb737cd0c21">

</br></br>

- ***위와 같은 표현의 단점***

1. 덧셈과 뺄셈을 수행하기 위해서는 부호 비트와 크기를 비교하여 처리하는 복잡한 과정 필요
2. 오버플로우 발생 시 잘못된 연산 결과를 반환함
3. 0에 대한 표현이 두 개 존재

&nbsp; &nbsp; => 즉, 실제 시스템에선 사용하지 않음. 이 단점들을 보완하기 위해 ***보수***라는 표현법 등장

</br>

### 보수 
**[ 1의 보수(1's complement) 표현  ]**
- 모든 비트들을 반전 (0  1, 1 0)

<img src ="https://github.com/fsm12/Hanbit-CS101/assets/74345771/fa180a85-4fb1-4bba-849d-447ba4f0551f">

</br></br>

**[ 2의 보수(2's complement) 표현 ]**
- 모든 비트들을 반전하고, 결과값에 1을 더함

<img src ="https://github.com/fsm12/Hanbit-CS101/assets/74345771/0ee31e67-a089-4f36-848b-b48034522f4e">

</br></br>

***[ 1의 보수 vs 2의 보수 ]***

&nbsp; &nbsp; 컴퓨터에서는 2의 보수를 더 많이 사용
  
1. 같은 길이의 비트들로 표현할 수 있는 수의 개수가 하나 더 많음
2. 0에 대한 표현이 한개만 존재하므로, 2의 보수만 -128을 표현할 수 있음
