# 보수법(complement)???
보수란 보충해주는 수를 뜻한다고 한다. 좀 더 자세히 알아보면 아래와 같다.

예시
- 3의 10의 보수 -> 7
- 11의 10의 보수 -> 89

일반적으로 $N$진법에 대해서 $N$의 보수, $N-1$의 보수가 존재한다.

예시
- 567의 9의 보수 -> 432
- 21의 9의 보수 -> 78

위의 예시로부터 1가지 규칙을 파악할 수 있다. 각 자리의 숫자에 대해서 해당 숫자를 $N - 1$ 의 보수를 만드는 숫자를 나열하면 전체가 $N - 1$의 보수가 된다.

해당 규칙을 2진수에 적용하면 다음과 같은 새로운 규칙으로 바라볼 수 있다.
> **2진수 X의 1의 보수는 X의 모든 비트를 반전한 것과 동일하다**

예시
- 1010 -> 0101
- 11 -> 00
# 보수법을 이용한 덧셈
## 보수법이 없다면?
8bit 크기의 2진수 숫자, 2개를 서로 더 한다고 가정해보자.
0000 0001 (1)
0000 0011 (3)
= 0000 0100 (4)
문제가 없는 것을 확인 가능하다.

하지만 그럼 8자리 중 1자리는 부호를 표현하기 위해서 포기해보자(MSB)
1000 1001 (-9)
0000 0011 (3)
= 1000 1100 (-12)
수학적으로는 -6 이 나와야 하지만 결과는 -12가 나온다.

정상 결과를 만들어내기 위해서는 MSB 비트를 기준으로 연산 동작을 바꿔줘야 한다. 하드웨어적으로는 MUX를 이용해서 다른 회로를 이용하도록 만들어야 한다.(코딩이었다면 조건문으로 나누어야 한다)

그리고 아래를 보면 0이 2가지로 표현된다.
- 0000 0000 (0)
- 1000 0000 (-0)

**장단점**
- 사람이 볼 때 MSB만 보고 양수, 음수를 파악할 수 있어 직관적이다.
- 0을 표현하는 방법이 2가지가 되어버린다.
- 셈을 할 때 고려해야 할 것이 많아지고 회로가 복잡해진다.

## 대안: 2의 보수를 활용
2의 보수를 음수라고 생각하고 연산을 진행하면 위에서 언급한 문제들이 해결됨
1111 0111 (-9)
0000 0011 (3)
= 1111 1010 (-6) <- 2의 보수를 취하면 양수 6이 됨!

**장점**
- 덧셈만을 써서 회로가 좀 더 단순화된다.
- 0을 1가지로 표현한다.

# 🔗 참고자료
- https://hs-archive.tistory.com/26